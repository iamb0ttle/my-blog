---
title: "DDD에서 값 검증은 어느 계층에서 해야 하는가?"
excerpt: "도메인 주도 설계에서 각 계층별로 수행해야 하는 검증의 책임 정리"
date: "2025-07-08"
tags: ["검증", "DDD", "설계"]
---

# 개요
_이 문서는 DDD 기반 시스템에서 값 검증을 어느 계층에서 수행해야 하는지 설명한다._

# 서론
소프트웨어에서 검증은 필수적이다.  
하지만 모든 검증이 동일한 것은 아니며, 검증의 종류에 따라 담당해야 하는 계층이 다르다.  
계층의 책임과 특성에 맞게 검증 위치를 결정하는 것이 중요하다.

# 계층 맥락
DDD(**Domain-Driven Design**)는 **설계 방법론**이지, 고정된 아키텍처가 아니다.  
**헥사고날**, **계층형**, **클린 아키텍처** 등 어떤 구조든 적용 가능하다.

하지만 **검증의 올바른 위치는 아키텍처 스타일과 무관**하며, **계층의 책임**에 의해 결정된다.

# 검증 위치
여기서는 세 가지 대표적인 검증 유형을 기준으로 설명한다.

- **입력값 / 필수값**  
- **유스케이스 조건**  
- **도메인 불변 조건**

## 1. 입력값 / 필수값 → **프레젠테이션 계층**
- **정의**: 사용자가 입력한 값, 반드시 입력해야 하는 값.  
- **이유**: 사용자와 가장 가까워 즉각적인 피드백 가능.  
- **예시**: 문자열 길이, 정규식, 필수 입력, 숫자 범위, 날짜 형식.

**아키텍처별 역할:**
- 헥사고날 → 어댑터  
- 계층형 → 컨트롤러  
- 클린 → 인터페이스 어댑터  

**예제:**
```js
// JavaScript 클라이언트/서버 검증
if (!email.includes("@")) {
  alert("유효하지 않은 이메일 주소입니다");
}
```

```csharp
// ASP.NET 모델 검증
[Required]
[StringLength(20)]
public string UserName { get; set; }
```

## 2. 유스케이스 조건 → **애플리케이션 계층**

* **정의**: 사용자의 관점에서 시스템 기능의 실행 조건을 확인.
* **이유**: 도메인 계층을 호출하기 전에 흐름 제어와 조건 검증.
* **예시**: 로그인 시도 제한, 권한 체크, 사전 조건 검증.

**아키텍처별 역할:**

* 헥사고날 → 애플리케이션 서비스 / 포트
* 계층형 → 서비스
* 클린 → 유스케이스 계층

**예제:**

```java
if (loginAttemptService.isExceeded(userId)) {
    throw new LoginLimitExceededException();
}
user.login(password);
```

## 3. 도메인 불변 조건 → **도메인 계층**

* **정의**: 도메인에서 항상 지켜져야 하는 비즈니스 규칙.
* **이유**: 도메인 객체의 무결성을 보장.
* **예시**: "배송 전까지만 주문 취소 가능", "가격은 양수여야 함".

**아키텍처별 역할:**

* 헥사고날 → 도메인 모델
* 계층형 → 도메인 엔티티 / VO
* 클린 → 엔티티 계층

**예제:**

```java
public class Product {
    private Money price;

    public Product(Money price) {
        if (price.isNegativeOrZero()) {
            throw new InvalidPriceException();
        }
        this.price = price;
    }
}
```

# 마무리

예전에는 대부분의 검증을 **프레젠테이션 계층**에서만 처리했지만, 이는 잘못된 설계였다.
이제는 **각 계층의 책임에 맞게** 검증을 배치하여 더 깔끔하고 유지보수 가능한 코드를 작성하고 있다.

