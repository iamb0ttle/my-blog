---
title: "프로세스 스케줄링 탐구"
excerpt: "프로세스 스케줄링의 근본적인 탐구"
date: "2025-05-17"
tags: ["OS", "운영체제", "프로세스", "스케줄링"]
---


# 개요
*이 문서는 운영체제에서 사용되는 프로세스 스케줄링 기법에 대해 논리적으로 고려해야 할 점과 조사한 내용을 정리한 자료입니다.*


# 서론
오늘날 우리는 한 대의 컴퓨터에서 여러 프로그램을 동시에 실행하고, 이들 사이를 매끄럽게 전환할 수 있습니다. 이는 자연스러운 일처럼 보이지만, 사실상 **프로세스 스케줄링(Process Scheduling)** 이라는 운영체제의 핵심 기능 덕분에 가능한 것입니다.  
따라서 프로세스 스케줄링은 당연하게 여겨지지만, 현대 운영체제의 기능을 떠받치는 필수 개념입니다.

스케줄링 기법은 운영체제가 지향하는 목표(예: 효율성, 응답성)에 따라 조금씩 다릅니다. 이 문서는 특정 스케줄링 방식 자체에 초점을 맞추기보다, 운영체제의 프로세스 스케줄링이 공통적으로 추구하는 목표와 원리를 살펴보는 데 목적이 있습니다.


# 프로세스 스케줄링이란?
프로세스 스케줄링은 운영체제가 **준비(ready) 상태에 있는 여러 프로세스 중에서 어떤 프로세스에 CPU를 할당할지, 언제, 얼마나 오랫동안 할당할지를 결정하는 메커니즘**을 말합니다.

운영체제마다 구체적인 목표는 다를 수 있지만, 일반적으로 다음을 추구합니다.

- **처리량(Throughput)** 향상
- **턴어라운드 타임(Turnaround Time)** 최소화
- **가용성(Availability)** 향상
- **신뢰성(Reliability)** 증대

이를 지원하기 위해 프로세스 스케줄링은 보통 다음을 목표로 합니다.

- **CPU 활용도** 최대화
- **처리량** 증가
- **응답 시간(Response Time)** 최소화
- **대기 시간(Waiting Time)** 및 **턴어라운드 타임** 최적화
- **공정성(Fairness)** 보장

즉, 운영체제의 성능 목표에 따라 각 프로세스가 CPU를 언제, 얼마나 배정받을지를 결정하는 것이 프로세스 스케줄링입니다.


# 비선점형 vs 선점형 스케줄링
프로세스 스케줄링에서 가장 중요한 구분 중 하나는 **비선점형(Non-Preemptive)** 과 **선점형(Preemptive)** 입니다. 거의 모든 스케줄링 알고리즘은 이 둘 중 하나에 속하며, 이 구분이 알고리즘의 동작 방식과 성능에 큰 영향을 미칩니다.

### 비선점형 스케줄링
비선점형 스케줄링에서는 한 번 CPU를 할당받은 프로세스는 **다른 프로세스가 강제로 빼앗을 수 없습니다**. 해당 프로세스가 실행을 마치거나, 자발적으로 CPU를 반납(예: I/O 요청)할 때까지 CPU를 점유합니다.

**장점:**
- 컨텍스트 스위칭 오버헤드가 적음 (평균 CPU 사용 시간 길어짐)
- 구현이 단순하고 쉽다

**단점:**
- 응답 시간 예측이 어려움
- 실시간 시스템에는 적합하지 않음
- 한 프로세스가 CPU를 독점하면 기아(Starvation) 발생 가능

### 선점형 스케줄링
선점형 스케줄링에서는 운영체제가 **실행 중인 프로세스를 중단하고 다른 프로세스로 교체**할 수 있습니다. 일반적으로 더 높은 우선순위의 프로세스가 등장했을 때 CPU 소유권을 강제로 넘깁니다.

**장점:**
- 다중 사용자나 실시간 시스템에 더 적합
- 우선순위가 높은 작업을 빠르게 처리 가능

**단점:**
- CPU 제어권이 자주 바뀌면 컨텍스트 스위칭 오버헤드가 커짐


# 프로세스 스케줄링의 구현 기준
현대 운영체제는 환경과 용도(모바일, 서버 등)에 따라 다양하게 구현되지만, **핵심 목표는 대부분 비슷**합니다.

프로세스 스케줄링은 주로 다음 지표를 기준으로 구현됩니다.

1. **CPU 활용도(CPU Utilization)**
    - CPU가 실제로 사용된 시간의 비율
    - 이상적인 활용도: 보통 40%~90% 이상

2. **처리량(Throughput)**
    - 단위 시간당 완료된 프로세스 개수
    - 예: 1초에 5개 프로세스 완료 → 처리량 = 5 processes/sec

3. **대기 시간(Waiting Time)**
    - 프로세스가 준비 큐(ready queue)에서 대기한 전체 시간
    - 평균 대기 시간이 짧을수록 시스템 응답성이 좋아짐

4. **턴어라운드 타임(Turnaround Time)**
    - 프로세스가 도착한 시점부터 종료까지 걸린 시간
    - 공식:  
      $턴어라운드\ 타임 = 완료\ 시간 - 도착\ 시간$

5. **응답 시간(Response Time)**
    - 요청이 들어온 시점부터 처음으로 CPU를 할당받기까지 걸린 시간
    - 응답 시간이 짧을수록 사용자 체감 속도가 향상됨

6. **공정성(Fairness)**
    - 프로세스들이 기아 없이 CPU를 고르게 배분받는 정도

7. **컨텍스트 스위칭 오버헤드(Context Switching Overhead)**
    - 프로세스 전환 시 발생하는 비용
    - 일반적으로 오버헤드를 줄이는 것이 바람직함

환경에 따라 추가적인 고려사항이 있을 수 있지만, 위 7가지 지표는 대부분의 운영체제에서 보편적으로 중요한 요소입니다.


# 결론
조사 결과, 운영체제마다 스케줄링 방식은 다르지만 **하드웨어와 소프트웨어 사이를 중재하며 사용자 경험을 극대화하는 것**이라는 공통 목표를 가지고 있었습니다. 따라서 각 스케줄링 전략은 주어진 조건에서 최상의 사용자 경험을 제공하도록 설계됩니다.


# 마무리
백엔드 개발 공부를 하면서 운영체제의 기초 개념인 프로세스 스케줄링을 이해하는 시간을 가졌습니다. 이를 통해 우리가 당연하게 생각하는 멀티태스킹이 사실은 사용자의 경험을 높이기 위해 치밀하게 설계된 스케줄링 전략에 기반하고 있음을 알게 되었습니다.
